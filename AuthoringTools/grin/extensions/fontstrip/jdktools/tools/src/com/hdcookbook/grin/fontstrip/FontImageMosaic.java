/*  
 * Copyright (c) 2008, Sun Microsystems, Inc.
 * 
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of Sun Microsystems nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 *  Note:  In order to comply with the binary form redistribution 
 *         requirement in the above license, the licensee may include 
 *         a URL reference to a copy of the required copyright notice, 
 *         the list of conditions and the disclaimer in a human readable 
 *         file with the binary form of the code that is subject to the
 *         above license.  For example, such file could be put on a 
 *         Blu-ray disc containing the binary form of the code or could 
 *         be put in a JAR file that is broadcast via a digital television 
 *         broadcast medium.  In any event, you must include in any end 
 *         user licenses governing any code that includes the code subject 
 *         to the above license (in source and/or binary form) a disclaimer 
 *         that is at least as protective of Sun as the disclaimers in the 
 *         above license.
 * 
 *         A copy of the required copyright notice, the list of conditions and
 *         the disclaimer will be maintained at 
 *         https://hdcookbook.dev.java.net/misc/license.html .
 *         Thus, licensees may comply with the binary form redistribution
 *         requirement with a text file that contains the following text:
 * 
 *             A copy of the license(s) governing this code is located
 *             at https://hdcookbook.dev.java.net/misc/license.html
 */


package com.hdcookbook.grin.fontstrip;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.GraphicsEnvironment;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.Iterator;
import javax.imageio.ImageIO;
import javax.imageio.ImageReadParam;
import javax.imageio.ImageReader;
import javax.imageio.stream.ImageInputStream;

/**
 * Represents the final font image file used by GRIN at runtime.
 * <p>
 * This image holds a mosaic of font images gathered from FontDesignImage(s).
 * The image file generated by this class is meant to be loaded onto a disc 
 * and used at xlet runtime together with "fontstrp.inf", which is an 
 * information file that describes all the font mosaics.
 */
public class FontImageMosaic {
    
    // Default max width for the final image
    static final int DEFAULT_WIDTH = 1000;
    // Version number to be recorded the font image info file.
    // The value should match the version number in 
    // com.hdcookbook.grin.fontstrip.FontImageFileInfo class.
    final static int VERSION_NUMBER = 2;
    
    BufferedImage image;
    int currPixelsX = 0;
    int currPixelsY = 0;
    int maxPixelsX = 0;
    int maxPixelsY = 0;
    int maxWidthInColumn = 0;
    int maxHeightInRow = 0;

    double scaleX;
    double scaleY;
    
    ImageReader reader = null;
    ImageReadParam param = null;
    Color[] colorsToIgnore = new Color[0];
    Color BACKGROUND_COLOR = new Color(0,0,0,0); // BG for the final image
    
    HashMap charInfo = new HashMap();
    int     maxLeading   = 0;    
    int     maxBoundAscent = 0;
    int     maxBoundDescent = 0;
    
    File    outputFile     = null;  // physical image file to output.
    
    public FontImageMosaic(int width, int height, double scaleX, double scaleY)
    {
        maxPixelsX = width;
        maxPixelsY = height;
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        image = new BufferedImage(maxPixelsX, maxPixelsY,
                    BufferedImage.TYPE_INT_ARGB);
    }
    
    public void addFontImages(FontDesignImage fontDesignImage) 
            throws IOException 
    {
        setImageSource(fontDesignImage.outputFile, 
                new Color[] { fontDesignImage.backgroundColor,
                              fontDesignImage.guidelineColor,
                              fontDesignImage.pixRectColor} );
        gatherFontImage(fontDesignImage);
    }

    public void setOutputFile(File outputFile) {
        this.outputFile = outputFile;
    }
    
    private void setImageSource(File sourceFile, Color[] colorsToIgnore)
              throws IOException 
    {
        BufferedInputStream source = 
                new BufferedInputStream(new FileInputStream(sourceFile));
        ImageInputStream iis = ImageIO.createImageInputStream(source);
        Iterator readers = ImageIO.getImageReadersByFormatName(
                FontStripImageGenerator.getFormatName(sourceFile));
        this.reader = (ImageReader) readers.next();
        this.reader.setInput(iis, true);
        this.param = reader.getDefaultReadParam();     
        this.colorsToIgnore = colorsToIgnore;
    }
    
    public void writeOutFiles(DataOutputStream infoOut) 
            throws IOException {

        BufferedImage image = getCurrentImage();
        if (image != null) {
            BufferedOutputStream out =
                    new BufferedOutputStream(new FileOutputStream(outputFile));
            // Write out the image file
            System.out.println("Writing : " + outputFile);
            boolean ok = ImageIO.write(image,
                    FontStripImageGenerator.getFormatName(outputFile), out);
            if (!ok) {
                throw new IOException("No image writer found.");
            }
            out.flush();
            out.close();
        }
       
       // then write out the info file.
       ByteArrayOutputStream baos = new ByteArrayOutputStream();
       DataOutputStream dout = new DataOutputStream(baos);
       
       int count = 0;
       for (Iterator iterator = charInfo.keySet().iterator(); iterator.hasNext(); ) {
           ImageMosaicCharInfo info = (ImageMosaicCharInfo) charInfo.get(iterator.next());
           dout.writeChar(info.ch);
           dout.writeInt(info.imageInMosaic.x);
           dout.writeInt(info.imageInMosaic.y);
           dout.writeInt(info.imageInMosaic.width);
           dout.writeInt(info.imageInMosaic.height);
           dout.writeInt(info.ascent);
           dout.writeInt(info.xOffset);
           dout.writeInt(info.width);
           count++;
       }
       dout.flush();
       dout.close();
       
       byte[] output = baos.toByteArray();
       infoOut.writeInt(count);
       infoOut.write(output);
    }

    /**
     * Scans a given bufferedImage and tris to trim the area containing
     * unneccessary pixels from all 4 edges.  In the trimmed down rectangle region,
     * this method also replaces unwanted colors with the default BACKGROUND_COLOR value. 
     * 
     * @param charImage BufferedImage to scan.
     * @return the region in the charImage that contains needed pixels.
     */
    private Rectangle filterPixelRegion(BufferedImage charImage) {
        int width = charImage.getWidth();
        int height = charImage.getHeight();
        Rectangle imageRect = new Rectangle(0,0,width,height);
        boolean found = false;

        // trim the left
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                int rgb = charImage.getRGB(x, y);
                if (isPixelNeeded(rgb)) {
                    found = true;
                    imageRect.x = x;
                    break;
                }
            }
            if (found) {
                break;
            }
        }

        if (imageRect.x == 0) { // nothing to draw!
            imageRect = new Rectangle(0, 0, 0, 0);
            return imageRect;
        }
 
        // trim the top       
        int left = imageRect.x;
        found = false;
        for (int y = 0; y < height; y++) {
            for (int x = left; x < width; x++) {
                int rgb = charImage.getRGB(x, y);
                if (isPixelNeeded(rgb)) {
                    found = true;
                    imageRect.y = y;
                    break;
                }
            }
            if (found) {
                break;
            }
        }

        // trim the right       
        int top = imageRect.y;
        found = false;
        for (int x = width-1; x >= left; x--) {
            for (int y = top; y < height; y++) {
                int rgb = charImage.getRGB(x, y);
                if (isPixelNeeded(rgb)) {
                    found = true;
                    imageRect.width = x + 1 - left;
                    break;
                }
            }
            if (found) {
                break;
            }
        }

        // trim the bottom       
        int right = left + imageRect.width;
        found = false;
        for (int y = height-1; y >= top; y--) {
            for (int x = left; x < right; x++) {
                int rgb = charImage.getRGB(x, y);
                if (isPixelNeeded(rgb)) {
                    found = true;
                    imageRect.height = y + 1 - top;
                    break;
                }
            }
            if (found) {
                break;
            }
        }

        // in the selected region, replace all unwanted color
        // with a default background color.
        int bottom = top + imageRect.height;
        for (int x = left; x < right; x++) {
            for (int y = top; y < bottom; y++) {
                if (!(isPixelNeeded(charImage.getRGB(x,y)))) {
                    charImage.setRGB(x, y, BACKGROUND_COLOR.getRGB());
                }
            }
        }
        return imageRect;
    }
    
    private boolean isPixelNeeded(int rgb) {
        for (int i = 0; i < colorsToIgnore.length; i++) {
            if (rgb == colorsToIgnore[i].getRGB()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Read in the area from the input image file.  The input is an image
     * generated by FontDesignImage.
     * 
     * @param  regionToScan the area in the input image to read in.
     * @return an instance of bufferedImage containing the sub image.
     */
    private BufferedImage readImage(Rectangle regionToScan) 
       throws IOException {
        
        if (reader == null) {
            System.err.println("ImageReader not set");
            return null;
        }
        
        param.setSourceRegion(regionToScan);
        BufferedImage charImage = new BufferedImage(regionToScan.width,
                regionToScan.height, BufferedImage.TYPE_INT_ARGB);
        param.setDestination(charImage);
        reader.read(0, param);
        return charImage;
    }
    
    /**
     * Gathers character images from image file specified in FontDesignImage,
     * filters unneeded areas, and records each character's bounding rectangle
     * and pixel rectangle info as an instance of ImageMosaicCharInfo
     * which later gets written out to the font image mosaic.
     */
    private void gatherFontImage(FontDesignImage file) 
            throws IOException 
    {
        Graphics2D g2 = GraphicsEnvironment.getLocalGraphicsEnvironment().createGraphics(image);
        char[] chars = file.chars;
        
        for (int i = 0; i < chars.length; i++) {
            char ch = chars[i];
             
            if (charInfo.containsKey(ch)) {
                throw new IOException("Character " + ch + " appears more than once in the final image");
            }
            
            CharMetrics metrics = (CharMetrics) file.charMetricsMap.get(ch);            
            Rectangle boundRect = metrics.getBoundingRect();
            Rectangle pixRect   = metrics.getPixRect();
            Rectangle regionToScan  = boundRect.union(pixRect); 
            regionToScan.grow(file.whitespace, file.whitespace);
            
            // Read the image from the original file.
            BufferedImage charImage         = readImage(regionToScan);
            // Filter out uncessesary region.
            Rectangle     subImageRect      = filterPixelRegion(charImage);
            // Write out the refined char image to the BufferedImage.
            Rectangle     imageRectInMosaic = writeSubImage(g2, charImage, subImageRect); 
            
            // Now let's figure out the font metrics info in relations to the 
            // char image that got written out.
            int ascent = metrics.getBaseline() - regionToScan.y-subImageRect.y;
            int boundAscent = metrics.getBaseline() + 1 - boundRect.y;
            int boundDescent = boundRect.height - boundAscent;
            int xOffset = regionToScan.x + subImageRect.x - boundRect.x;

            if (subImageRect.height == 0) {
                ascent = 0;
            }
            int width = boundRect.width;

            // Write out the char position in the final font image mosaic,
            // and the asent/boundRect info for this char.
            ImageMosaicCharInfo info = new ImageMosaicCharInfo(ch);
            info.imageInMosaic = imageRectInMosaic;
            info.ascent = (int) Math.round(scaleY * ascent);
            info.width = (int) Math.round(scaleX * width);
            info.xOffset = (int) Math.round(xOffset);
            charInfo.put(ch, info);
            
            // Character's bounding rect and ascent info can be used
            // to calculate the char's ascent, descent and advance.
            // Meanwhile character leading, and max ascent and descent is
            // recorded per font.  Bound ascent is based on the bound rect
            // of rendering the font, and not the actual pixels.

            boundAscent = (int) Math.round(scaleY * boundAscent);
            boundDescent = (int) Math.round(scaleY * boundDescent);
            int leading = (int) Math.round(scaleX * metrics.getLeading());
            maxLeading = Math.max(maxLeading, leading);
            maxBoundAscent = Math.max(maxBoundAscent, boundAscent);
            maxBoundDescent = Math.max(maxBoundDescent, boundDescent);
        }
    }
    
    private BufferedImage getCurrentImage() {
        int width = (currPixelsX > maxWidthInColumn) 
                ? currPixelsX : maxWidthInColumn;
        int height = currPixelsY + maxHeightInRow;
        if (width <= 0 || height <= 0) { // no image to write!
            return null;
        }
        return image.getSubimage(0,0,width,height);
    }

    private Rectangle writeSubImage(Graphics2D g2, BufferedImage charImage, 
                                    Rectangle subImageRect) 
               throws IOException 
    {
        int width = (int) Math.round(subImageRect.width * scaleX);
        int height = (int) Math.round(subImageRect.height * scaleY);
        if (currPixelsX + width >= maxPixelsX) { 
            // calculating the location of the char image in the mosaic.
            if (maxWidthInColumn < currPixelsX) {
                maxWidthInColumn = currPixelsX;
            }
            currPixelsX = 0;
            currPixelsY += maxHeightInRow;
            maxHeightInRow = 0;
        }
        
        Rectangle drawRegion 
            = new Rectangle(currPixelsX, currPixelsY, width, height);
        
        if (!drawRegion.isEmpty()) {
            g2.drawImage(charImage, drawRegion.x, drawRegion.y,
                    drawRegion.width + drawRegion.x,
                    drawRegion.height + drawRegion.y,
                    subImageRect.x, subImageRect.y,
                    subImageRect.width + subImageRect.x,
                    subImageRect.height + subImageRect.y, null);
        }
   
        if (maxHeightInRow < height) {
            maxHeightInRow = height;
        }
        currPixelsX += width;
        
        return drawRegion;
    }
    

    
    /**
     * Information that needs to be written out to the fontmetrics info file.
     */
    class ImageMosaicCharInfo {        
        char ch;
        Rectangle imageInMosaic;
        int ascent;     // True ascent of this character in image
        int xOffset;    // Offset of where the font image should be drawn
        int width;

        public ImageMosaicCharInfo(char ch) {
            this.ch = ch;
        }
    }
}
