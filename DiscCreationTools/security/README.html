<html>
<head>
<title>Security Tools</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
<style type="text/css">
<!--
BODY {
        font-family:  Verdana, Arial, Helvetica, sans-serif
}
-->
</style>
</head>
<body>
<h1><center>Security  Tools</center></h1>
<p>

This project contains the security tools required for developing BD-J
Applications.
  
Here is the list of tools we currently have available:
<p>

<ul>
	<li><a href="#BDCert">BDCertGenerator</a> - generates the root, application and binding unit root certificates according to BD-J Specification.
<p>
<li> <a href="#BDSigner">BDSigner</a> -- signs the jars using keys generated by the BDCertGenerator.
This tool also <a href="#BUMF"> signs BUMF</a> (Binding Unit Manifest File) and
generates online.sig file for <a href="#ONLSIG"> online access</a>.
<p>
<li> <a href="#ONLINE">OnlineKeyTool</a>- Imports online credentials from BDA into a keystore
<p>
<li> <a href="#BDCred"> BDCredentialSigner</a> - generates the file credentials and signs the jar file.
<p>
<li> <a href="#DEF">Default values</a> - Tables of default values (aliases, filenames, passwords etc) used by the above tools.
</ul>
<p>

<h2><a name=Intro>Introduction to Blu-ray Security</a></h2>
<p>
A Blu-ray disc with signed JAR files must contain an Application Root 
Certificate.  This is often just called a "Root Certificate," and it is
described in part 3-2 section 12.2.7.  The application root certificate is
stored on the optical disc as app.discroot.crt.  A signed JAR file is
verified against this root certificate.  This ensures that the JAR file
was signed by the same party that generated the app.discroot.crt file,
or by a second party that was permitted access through a trust chain.
<p>
The first step, then, in making a signed Blu-ray disc is to generate a
root keypair.  This is stored in a secure keystore.  A working root keypair
can be created with the cookbook tools, as described in the next section.
The root keypair consists of a public and a private key.  The public key
is stored in the file app.discroot.crt.  Sometimes, you may hear people
say that a JAR needs to be "signed with the root certificate," but this
is really a shorthand for signing with the private key that corresponds
to the public key contained in the root certificate.  A root certificate
can't sign anything, because it lacks the private key.
<p>
Another public/private keypair can be generated, with the root keypair as
its parent.  This process can continue recursively, to make a leaf certificate
at any desired distance from the root.  For Blu-ray, a depth of two keypairs
is recommended, but three is also common.  A maximum depth is set in the
guidelines, but there's probably no reason to want to go beyond three or four
anyway.  A longer certificate chain takes more time during jar verification.
<p>
Making an intermediate keypair allows the entity that generated the root
certificate to grant permission to sign xlets based on that root certificate,
without giving out the private key associated with the root certificate.  This
can be useful for managing vendors, so you can tell who signed what.  The
leaf keypair (at the end of the chain) is used to sign the JAR file(s) of
the xlet.  A signed JAR file contains a certificate chain from the root
certificate to the leaf certificate.  Again, people will often say the JAR
is "signed with the leaf certificate," but this is actually shorthand for
signing the JAR with the private key of the keypair used to generate the leaf
certificate.  In Blu-ray, the leaf certificate must contain the organization
ID associated with the JAR.
<p>
For VFS updates, the binding unit manifest file (BUMF) is signed with a 
different keypair.  This keypair is the one used to generate 
the Binding Unit Root Certificate.  This is specified in part
3-2 sections 12.2.8.1.2 and 12.2.8.1.3, and the certificate for
this rootk keypair is stored in the file bu.discroot.root.
<p>
Finally, there is a third signing procedure, for the "online certificate."
This is documented in part 3-2 section DD.2.1, and it involves signing
the file app.discroot.crt.  Having an online certificate and Signing an
app.discroot.crt is not required.  However, players have a configurable
setting that allows the consumer to disallow network connections for
discs that do not have an application root certificate that is signed
with this mechanism.  If you're
making a disc for test or demo purposes, you can just change the player
setting, but if you're making a commercial disc it makes sense to include
the online signature.

<h2> Certificate Generation and Signing </h2>



There are two steps involved in signing a BD-J application.
<p>
Step 1: Generate the ceritficate{s} and key{s} for signing.<br>
Step 2: Sign the application jar using a key{s} generate above.
<p>

<h3><a name=BDCert>Step 1: Certificate Generation:</a></h3>

BDCertGenerator tool can be used for generating certificates for
the BD-J Platform. This tool generates three types of certificates
for singing the application jar and the Binding Unit Manifest File (BUMF).

<h4>SYNOPSIS</h4>

<BLOCKQUOTE>
	<P><B><CODE>BDCertGenerator -root|-app|-binding [options] [organization_id]</CODE></B></P> 
</BLOCKQUOTE>
<p>
The <b>mandatory</b> argument for this tool is the type of the certificate.
It could be either:
<p>

 	"-root" or "-app" or "-binding"
<p>
The organization_id (orgID) is required based on the type of certificate.
For example,

If the certificate type is "root", the orgID is not mandated.
<p>
If the type is "app", the orgID is typically required, unless it's a
non-leaf certificate (i.e the certificate is not used for signing the application). In this case the tool does not mandate the orgID but warns the user about
adding an orgID in the certificate.
<p>
And finally, if the certificate type is "binding" an orgID corresponding
to the one used in the bumf.xml (or whatever BUMF file name is) must be used.
<p>
For other options type: 
<BLOCKQUOTE>
<PRE>
	BDCertGenerator -help
</BLOCKQUOTE>
</PRE>

<h4>Example:</h4>
Lets say, SEC_JAR, an environment variable represents the path for 
hdcookbook security jar.
	<BLOCKQUOTE>
		<PRE>set SEC_JAR=&lt;path of security jar&gt;</PRE>
	The security.jar typically resides in the location below, please make sure that it does.
	<BLOCKQUOTE>
	<PRE>&lt;HDCOOKBOOK_HOME&gt;\DiscCreationTools\security\build\security.jar</PRE>
	</BLOCKQUOTE>
<p>
And BC_JAR, an environment variable represents path for Bouncy Castle Provider
jar. 
We are using: bdprov-jdk15-137.jar, a bouncycastle distribution, it should
be fine to use the later versions as well.
A copy of which can be found in the "resource" directory of security tools.
For more information see: <a href="http://www.bouncycastle.org/"> Bouncy Castle
	 Provider</a>.
	<BLOCKQUOTE>
		<PRE>set BC_JAR=&lt;path of bouncy castle jar&gt;</PRE>
	</BLOCKQUOTE>
	<p>
	If signer is used, then one more jar is required in the classpath,
	this jar should contain the JDK JarSigner tool. For Windows platform
	this jar is found in the directory below:
	<BLOCKQUOTE>
		<PRE>set TOOLS_JAR=&lt;java.home&gt;\lib\tools.jar</PRE>
	</BLOCKQUOTE>
	
	Set the CLASSPATH variable:
		<BLOCKQUOTE>
		<PRE>set CLASSPATH=%CLASSPATH%;%SEC_JAR%;%BC_JAR%;%TOOLS_JAR%</PRE>
	</BLOCKQUOTE>
	<p>
	<hr>
	<b>Note:</b> All the examples below assume that the CLASSPATH variable is set as above before invoking the security tools.
	<hr>
	<p>	
Here is the command line for generating a root certificate.
<p>
<BLOCKQUOTE>
<PRE>java net.java.bd.tools.security.BDCertGenerator -root 7fff0001</PRE>
</BLOCKQUOTE>
Here is the command line for generating an application certificate.
<p>
<BLOCKQUOTE>
<PRE>java net.java.bd.tools.security.BDCertGenerator -app 7fff0001</PRE> 
</BLOCKQUOTE>
Place the generated certificate file: app.discroot.crt,
in the <BLOCKQUOTE><PRE>BDMV\CERTIFICATE</BLOCKQUOTE></PRE> and
<BLOCKQUOTE><PRE>BDMV\CERTIFCATE\BACKUP</BLOCKQUOTE></PRE> directories.

<h3><a name=BDSigner>Step 2: Signing application jar</a></h3>

BDSigner tool can be used for signing the application jar. This tool can
also be used for signing BUMF using the Binding Unit Root certificate. It can
also generate "online.sig" file provided BDA generated private key is imported
into the keystore.

<H4>SYNOPSIS</H4>

<BLOCKQUOTE>
	<P><B><CODE>BDSigner [options] BUMF|app.discroot.crt|jarfiles</B></P> 

</BLOCKQUOTE>
<p>
The <b>mandatory</b> argument for this tool is one or more jarfiles, or a
BUMF file in case BUMF signing or an application certificate for online.sig
generation.
<p>
For other options type:
	<BLOCKQUOTE>
	<PRE>
	BDSigner -help.
	</PRE>
	</BLOCKQUOTE>
<p>
<h4>Example:</h4>
The signing key for the BDSigner to sign the jars is generated in Step 1.
<p>
Here is the command line for signing the jar.
<p>
	<BLOCKQUOTE>
	<PRE>
	java net.java.bd.tools.security.BDSigner 00000.jar 
	</PRE>
	</BLOCKQUOTE>
BDsigner is built on top of JDK's jarsigner which is bundled in tools.jar 
 
<p>

<h4> Why can't we just use the standard "jarsigner" tool in Java SE?</h4>

Blu-Ray specification requires an extra header in the signature 
manifest file in signed jar files.  The signature manifest file 
must have an attribute called "BDJ-Signature-Version" with the 
value of "1.0". Please refer to the section "12.1.4.2" of the
"System Description Blu-Ray Disc Read-Only Format - Part 3
Audio Visual Basic Specifications" - DRAFT Version 2.02".

The "jarsigner" tool in Java SE generates signature manifest 
file automatically. There is no way to specify extensions to 
the signature manifest file. So, it can not be used to sign
jars for BD-J. 
<hr>

<h3><a name=BUMF>Signing BUMF</a></h3>
Here is an example of signing a BUMF using some of the options provided
by the tools described above.

Lets generate a binding unit root certificate with an alias:bucert and
a key password: mypass, created in a new keystore: bindingstore, with a
password: mystorepass
<p>

	Here is the command line to generate a binding unit root certificate.
	<BLOCKQUOTE>
	<PRE>
	java net.java.bd.tools.security.BDCertGenerator -binding -keystore binding.store -storepass mystorepass -alias mybinder -keypass mypass -debug 00000001 
	</PRE>
	</BLOCKQUOTE>
	<p>

	The tool prints the following debug messages:
	   
	<BLOCKQUOTE>
	<PRE>
	Certificate stored in file <bu.discroot.crt>
	Starting the verfication for certificate file:bu.discroot.crt 
	Checking the certiticate
	Done with the verification for the certificate file:bu.discroot.crt
        </PRE>
	</BLOCKQUOTE>
	<p>

Now, lets sign a BUMF file named: bumf.xml using the above keystore.
<p>
Here is the command line to sign BUMF
	<BLOCKQUOTE>
	<PRE>
	java net.java.bd.tools.security.BDSigner -keystore binding.store -storepass mystorepass -alias mybinder -keypass mypass -debug bumf.xml
	</PRE>
	</BLOCKQUOTE>
	<p>

	The tool prints the following debug messages:
	<BLOCKQUOTE>
	<PRE>
	Signer of bumf.xml file is:mybinder
	Verifier of bumf.sf file is:mybinder
	BUSF Verification PASSED..
	The signed file is written into:bumf.sf
        </PRE>
	</BLOCKQUOTE>
	<p>
	<hr>
	<b>Note:</b> If the <a href="#DEF">default</a> keystores, passwords and aliases are used, then the command line for signing a BUMF file is very simple as below:
  	<BLOCKQUOTE>
  	<PRE>
  	java net.java.bd.tools.security.BDCertGenerator -binding 00000001
  	java net.java.bd.tools.security.BDSigner bumf.xml
  	</PRE>
  	</BLOCKQUOTE>
  	<p>
	<hr>
<h3><a name=ONLSIG></a>Online Signature generation</h3> When a BD-J application
tries to access network the player checks for online authorization for the disc.
The online access is granted through online.sig, online.crt and online.crl files. 
The online.crt and online.crl are provided by BDA and online.sig file is generated
using the credentials obtained from BDA.

<p>The BDSigner generates online.sig file either by directly using BDA formatted key and
certificate files or by reading them from the keystore. A utility called
 <a href="#ONLINE">OnlineKeyTool</a> enables importing keys from the
 BDA files into the Java Keystore. There by enabling storage of critical credentials
 in a single, protected place like keystore.
</p>
Here is the command line to generate a online.sig file using BDA provided files.
The online.sig generation may nor may not require (see below) app.discroot.crt file.
	<BLOCKQUOTE>
	<PRE>
	java net.java.bd.tools.security.BDSigner -debug -onlinekey bda/keyfile.bin -onlinecrt bda/online.crt app.discroot.crt
	</PRE>
	</BLOCKQUOTE>
	<p>
    This results in online.sig generation with following debug messages:
	<BLOCKQUOTE>
	<PRE>
        Content owner ID: 100
        Content owner Name: My Studio Ltd
        Imported online keys into keystore: keystore.store with an alias: "onlinecert"
        Signed online cert stored in file online.sig
        Online Cert signature verification PASSED
    </PRE>
	</BLOCKQUOTE>
    <hr>
	<b>Note:</b> The signature verification (for sanity check) is performed on the
    generated file only when -debug is used. This is in general true for other options as well.
    <hr>
    <p>
    If the app.discroot.crt file is not present then use -nodiscroot option as below:
	<BLOCKQUOTE>
	<PRE>
	java net.java.bd.tools.security.BDSigner -debug -nodiscroot -onlinekey bda/keyfile.bin -onlinecrt bda/online.crt
	</PRE>
	</BLOCKQUOTE>
<p>
<h3><a name="ONLINE">OnlineKeyTool:</a></h3>

This tool enables importing the BDA provided private key file and the public key from
online.crt file into a Java Keystore. A new keystore can be used or the keys can
be added to an existing keystore.
<p>
The public key is stored in a self signed certificate. This is not a certificate
signed using BDA public key.
<p>
<H4>SYNOPSIS</H4>
<BLOCKQUOTE>
	<P><B><CODE>OnlineKeytool [options]   path-to-private-key-file   path-to-online.crt</B></P>
</BLOCKQUOTE>
<p>
The <b>mandatory</b> argument for this tool is the private key file and the online.crt file.
<p>
For other options type:
	<BLOCKQUOTE>
	<PRE>
	OnlineKeytool -help.
	</PRE>
	</BLOCKQUOTE>
<p>
<h4>Example:</h4>
<p>
Here is the command line to import a key pair from BDA provided files.
	<BLOCKQUOTE>
	<PRE>
	java net.java.bd.tools.security.OnlineKeytool -debug  bda/keyfile.bin  bda/online.crt
	</PRE>
	</BLOCKQUOTE>
	<p>
The above command results in a keystore that contains a key entry set to
the public and private online keys obtained from BDA. When no options are provided
the <a href="#DEF">default</a> keystore parameters are used.
<p>
<h3><a name=BDCred>Credential Generation and Signing:</a></h3>

BDCredentialSigner tool generates persistant file credentials and BUDA
credentials for accessing the common data area across organizations (orgIDs).
It can be used both by Grantor (one who "grants" access to
its own data area by someone else). and a Grantee (one who accesses Grantor's
data area).

This tool is used in a workflow as below.
<ul>
	<li>Grantor uses this tool to generate <a href=#CREDGEN> signed credentials</a>,
	given a Permission Request File (PRF) received from a grantee for
       	verification and signature.
	<li>The Grantee then uses this tool to <a href=#CREDSIGN> update certificates and sign</a>
	a jar file. The certificates required for verification of Grantor's
	signature inside the PRF are provided by the Grantor.
</ul>


<H4>SYNOPSIS</H4>

<BLOCKQUOTE>
	<P><B><CODE>BDCredentialSigner [options] PRF jarfile<CODE></B></P> 
</BLOCKQUOTE>
<p>

With no options specified this tool does both tasks, i.e generates signed
credentials (Grantor) and updates certificates and signs the jar file (Grantee).
This is useful in testing environments.
<p>

For more options type: 
<BLOCKQUOTE>
<PRE>
	BDCredentialSigner -help
</BLOCKQUOTE>
</PRE>
<p>
In a real environment, both these processes are disjoint as described in
a workflow above. The tool options for going with this workflow are described
below.

<h4><a name=CREDGEN>Signing Credentials:</a></h4>
    The command line option: -gencred generates the signed credentials.
    <p>
    <i>Input</i>: Permission request file, access to grantor's private key (by means
           of keystore) for signing and application disc root certificate
	   of the grantee. 
<p>
<i>Output</i>: A permission request file with signed credentials and
	the grantor's certificate chain stored in the file:
	"grantorchain.crt"
	    <p>
	    Example:
	    The example below uses the same default values as that of the
	    BDCertGenerator but the name of the keystore is:
	    "grantor.store" (which is a default grantor keystore used by this tool).
	    The default values save on typing. 
	   
<BLOCKQUOTE>
<PRE>
    BDCredentialSigner -gencred -gecert grantee.discroot.crt bluray.MyXlet.perm
</PRE>
</BLOCKQUOTE>

    The above command line results in a permission request file that is populated
    with credential elements containing the grantor's signature.
    The grantor certificate chain is store in the file: "grantorchain.crt" 

<h4><a name=CREDGEN>Signing Jar:</a></h4>
    The command line option: -updatecerts updates the certificates and signs the jar.
<p>
<i>Input</i>: Permission request file with signed credentials,
	grantor's certificate chain, both these are received from the grantor,
	grantee private key information for signing the jar
	(by means of keystore), jar file that uses the credentials and needs
       	to be signed.
	<p>
<i>Output</i>: The signed jar file updated with signed credentials and grantor certificates.
    <p>
    Example:
<BLOCKQUOTE>
<PRE>
    BDCredentialSigner -updatecert -gacerts grantorchain.crt bluray.MyXlet.perm 00000.jar 
</PRE>
</BLOCKQUOTE>
<p>

If none of the above options are specified, then the tool performs both
the steps above
In this case the specifed permission request file is extracted
from the specified jarfile to be signed.
<p>
<i>Input</i>: Grantor and Grantee's keystore information for signing.
	  Location of permission request file with in the given jarfile
          to be signed
	  <p>
<i>Output</i>: The signed jar file updated with credentials.
	  <p> 
	  Example:
		This example shows use of custom values for key related information.

<BLOCKQUOTE>
<PRE>
    BDCredentialSigner -gastore GA.keystore -gastorepass GApass -gaalias GA -gakeypass GApass 
	               -store GE.keystore -storepass GEpass -alias GE -keypass GEpass
		        myxlet/bluray.MyXlet.perm 00000.jar 
</PRE>
</BLOCKQUOTE>
   
<h4> Permission Request File Example </h4>
Below is an example of a PRF created by the Grantee before sending it to the
Grantor for signing. 
The PRF has all fields of persistent file credentials but the
&lt;signature&gt; and the &lt;certchainfileidi&gt; elements. 
<p>
Consider the following PRF, that is requesting a write access to a file:
"01/4000/tmp.txt" located in the Application Data Area of another disk
that belongs to an OrgID:7fff3456. The access validity is from now, till
10/12/2050.

<PRE>
<XMP>
 <?xml version="1.0" encoding="UTF-8" standalone="no"?>
 <n:permissionrequestfile xmlns:n="urn:BDA:bdmv;PRF" appid="0x4001" orgid="0x7fff1234">
   <file value="true"/>
   <applifecyclecontrol value="true"/>
   <servicesel value="true"/>
   <userpreferences read="true" write="false"/>
  <persistentfilecredential>
      <grantoridentifier id="0x7fff3456"/>
      <expirationdate date="10/12/2010"/>
      <filename read="true" write="true">01/4000/tmp.txt</filename>
  </persistentfilecredential>
 </n:permissionrequestfile>
</XMP>
</PRE>
<p>
The Grantor received the above PRF, and Grantee's application disc
root certificate, signs the credentials and generates the PRF below:
<p> 
 The output PRF with -gencred option: 
 <p>
<PRE>
<XMP>
      ......
     <persistentfilecredential>
       <grantoridentifier id="0x7fff3456"/>
       <expirationdate date="10/12/2010"/>
       <filename read="true" write="true">01/4000/tmp.txt</filename>
       <signature>KSrmmBCGY9RkOCug6HRWjBLC29VkCOKBoPAVbbxv+q7Ed4iVv6tzerrkXudjs1rez
 CYtrGysX0VK&#13;
 qKE/GlqQy2ICTWl8RVdWHFR/1KobWcsghIqtXeyR89pKrUWw8Z52o00pQsV351MrYAb7wZUzRozO&#13
 ;
 1VWAViCRoKkjHbxw/pI=</signature><certchainfileid>MGIwXTEPMA0GA1UEAwwGU3R1ZGlvMR8
 wHQYDVQQLDBZDb2Rlc2lnbmluZyBEZXBhcnRtZW50MRww&#13;
 GgYDVQQKDBNCREpDb21wYW55LjAwMDAwMDAxMQswCQYDVQQGDAJVUwIBAQ==</certchainfileid>
 </persistentfilecredential>
 </n:permissionrequestfile>
 ...
</XMP>
</PRE>

<hr>
<b>Note:</b> The permission request file must always be placed in a directory as
		it would appear inside the jar bundle. For example: if the
		application sources that require PRF are placed in a package
		called: com.foo.bar, then the PRF file should be placed in a
	       	directory: com\foo\bar\bluray.MyApp.perm. 
		The BDCredentialsSigner expects the whole path in the PRF
	       	argument for both credential and jar signing.
<hr>
<br>
<h3><a name=DEF>Tables of default values used:</a></h3>
<h4>Keystore:</h4>
<table border="2" cellspacing="2" cellpadding="4">
    <thead>
        <tr>
            <th>Keystore Filename</th>
            <th>Keystore Password</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>keystore.store</td>
            <td>keystorepassword</td>
        </tr>
    </tbody>
</table>
<br>
<h4> Keys and Certificates defaults: </h4>
<table border="4" cellspacing="2" cellpadding="4">
    <thead>
        <tr>
            <th>Certificate Type</th>
            <th>Alias</th>
            <th>Password</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Root Certificate</td>
            <td>rootcert</td>
            <td>rootcertpassword</td>
        </tr>
        <tr>
            <td>Application Certificate</td>
            <td>appcert</td>
            <td>appcertpassword</td>
        </tr>
        <tr>
            <td>Binding Unit Root Certificate</td>
            <td>bucert</td>
            <td>rootcertpassword</td>
        </tr>
        <tr>
            <td>BDA Online Certificate</td>
            <td>onlinecert</td>
            <td>onlinecertpassword</td>
        </tr>
    </tbody>
</table>
<br>
<h4> Output file names generated by the tools: </h4>
<table border="4" cellspacing="2" cellpadding="4">
    <thead>
        <tr>
            <th>Filename</th>
            <th>Description</th>
            <th>Tool name (created by)</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>keystore.store (new or updated)</td>
            <td>Newly created/added keys and certificates</td>
            <td>BDCertGenerator and OnlineKeyTool</td>
        </tr>
        <tr>
            <td>app.discroot.crt</td>
            <td>Disc root certificate for jar verfication</td>
            <td>BDCertGenerator</td>
        </tr>
        <tr>
            <td>bu.discroot.crt</td>
            <td>Binding unit root certificate for BUMF verification </td>
            <td>BDCertGenerator</td>
        </tr>
        <tr>
            <td>*.sf (example: bumf.sf)</td>
            <td>Signed BUMF for VFS updates</td>
            <td>BDSigner</td>
        </tr>
        <tr>
            <td>online.sig</td>
            <td>Online signature file</td>
            <td>BDSigner</td>
        </tr>
    </tbody>
</table>
<br>
    <h4> Credential Generation, Grantor's defaults:</h4>
<table border="2" cellspacing="2" cellpadding="4">
    <thead>
        <tr>
            <th>Keystore</th>
            <th>Store Password</th>
            <th>Alias</th>
            <th>Key Password</th>
            <th>Certifcate chain filename</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>grantor.store</td>
            <td>keystorepassword</td>
            <td>appcert</td>
            <td>appcertpassword</td>
            <td>grantorchain.crt</td>
        </tr>
    </tbody>
</table>
<br>
<h4> Credential Generation, Grantee's defaults:</h4>
<table border="2" cellspacing="2" cellpadding="4">
    <thead>
        <tr>
            <th>Keystore</th>
            <th>Store Password</th>
            <th>Root Alias</th>
            <th>Alias</th>
            <th>Key Password</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>keystore.store</td>
            <td>keystorepassword</td>
            <td>rootcert</td>
            <td>appcert</td>
            <td>appcertpassword</td>
        </tr>
    </tbody>
</table>
<hr>






